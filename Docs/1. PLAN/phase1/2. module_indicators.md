📁 Docs/Plan/Phase1/module_indicators.md
📌 목적
다양한 기술적 지표를 계산하여 데이터 기반의 매매 신호 생성을 지원합니다.
이동평균선(MA), RSI 등 트레이딩 전략에서 자주 사용되는 지표를 포함합니다.
📁 디렉터리 구조
indicators/
├── __init__.py              # 모듈 초기화 파일
├── trend_indicator.py       # 추세 지표 (이동평균선 계산)
├── momentum_indicator.py    # 모멘텀 지표 (RSI 계산)
├── macd_indicator.py        # MACD 지표 계산
└── feature_generator.py     # AI/ML 모델 학습용 피처 생성

✨ 주요 기능
1️⃣ 추세 지표
이동평균선(MA) 계산: 단기 및 장기 이동평균선을 계산하여 추세 방향을 분석.
MACD(Moving Average Convergence Divergence) 계산: 단기와 장기 이동평균의 차이를 활용하여 시장의 추세를 파악.
2️⃣ 모멘텀 지표
RSI(Relative Strength Index): 특정 자산의 과매수 또는 과매도 상태를 파악하여 시장 모멘텀을 분석.
3️⃣ AI/ML 학습용 피처 생성
각 기술적 지표의 결과를 결합하여 머신러닝 학습에 적합한 피처(feature) 데이터셋 생성.

📄 주요 파일 설명
1️⃣ __init__.py
목적:
indicators 모듈을 패키지로 인식하게 하는 초기화 파일.
주요 역할:
공용 함수 및 클래스를 로드.
다른 모듈에서 indicators 폴더를 패키지로 사용할 수 있도록 설정.
2️⃣ trend_indicator.py
목적:
이동평균선(MA) 및 MACD를 계산하여 시장의 추세를 분석.
주요 기능:
단기 이동평균선(MA_short) 계산.
장기 이동평균선(MA_long) 계산.
MACD(Moving Average Convergence Divergence) 계산.
주요 함수:
calculate_ma(data, window)
특정 창 크기(window)에 따른 이동평균선을 계산합니다.
입력값:
data: 입력 데이터프레임.
window: 이동평균 창 크기.
출력값: 이동평균선 데이터.
예제 코드:
python
복사
편집
def calculate_ma(data, window):
    """
    이동평균선 계산 함수
    """
    return data['close'].rolling(window=window).mean()
calculate_macd(data, short_window=12, long_window=26, signal_window=9)
MACD와 시그널 라인을 계산하여 시장 추세를 파악.
입력값:
data: 입력 데이터프레임.
short_window: 단기 이동평균 창 크기.
long_window: 장기 이동평균 창 크기.
signal_window: MACD 신호 라인 창 크기.
출력값: MACD 및 시그널 라인 데이터.
예제 코드:
python
복사
편집
def calculate_macd(data, short_window=12, long_window=26, signal_window=9):
    short_ma = data['close'].rolling(window=short_window).mean()
    long_ma = data['close'].rolling(window=long_window).mean()
    macd = short_ma - long_ma
    signal = macd.rolling(window=signal_window).mean()
    return macd, signal
3️⃣ momentum_indicator.py
목적:
RSI를 계산하여 시장의 과매수/과매도 상태를 분석.
주요 기능:
RSI 값 계산 및 시장 상태 평가.
주요 함수:
calculate_rsi(data, period=14)
RSI(Relative Strength Index)를 계산.
입력값:
data: 입력 데이터프레임.
period: RSI 계산 기간.
출력값: RSI 값.
예제 코드:
python
복사
편집
def calculate_rsi(data, period=14):
    delta = data['close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))
4️⃣ feature_generator.py
목적:
기술적 지표를 결합하여 AI/ML 모델 학습용 피처 데이터를 생성.
주요 기능:
모든 지표 데이터를 병합하여 피처(feature) 데이터프레임 생성.
주요 함수:
generate_features(data)
이동평균선, RSI, MACD 등 모든 지표 데이터를 병합.
입력값:
data: 입력 데이터프레임.
출력값: 피처 데이터프레임.
예제 코드:
python
복사
편집
def generate_features(data):
    data['ma_short'] = calculate_ma(data, window=12)
    data['ma_long'] = calculate_ma(data, window=26)
    data['rsi'] = calculate_rsi(data)
    data['macd'], data['macd_signal'] = calculate_macd(data)
    return data

🔗 통신 구조 및 의존성
1️⃣ 데이터 흐름
plaintext
preprocessor.py → indicators/trend_indicator.py
→ indicators/momentum_indicator.py
→ indicators/feature_generator.py → signals/

2️⃣ 주요 의존성
외부 라이브러리:
pandas: 데이터프레임 처리.

📅 개발 일정
설계 및 검토:
지표 계산 알고리즘 설계 및 검토 - 3일.
개발 및 테스트:
이동평균선(MA) 구현 및 테스트 (trend_indicator.py) - 2일.
RSI 구현 및 테스트 (momentum_indicator.py) - 3일.
MACD 구현 및 테스트 (trend_indicator.py) - 2일.
피처 생성 구현 (feature_generator.py) - 2일.
통합 및 검증:
데이터 전처리 → 지표 계산 → 신호 생성 테스트 - 3일.

📅 테스트 계획
1️⃣ 단위 테스트:
- 각 함수별 입력 및 출력값 검증.
- 잘못된 데이터 처리 시 오류 처리 검증.
2️⃣ 통합 테스트:
- 지표 계산 결과가 신호 생성에 적절히 반영되는지 확인.
- AI/ML 모델 학습을 위한 피처 생성 정확도 평가.
3️⃣ 예제 데이터 시나리오:
- 가상의 시장 데이터를 사용하여 MA, RSI, MACD 계산 결과 검증.

## 📘 참고 문서 및 링크
- Docs/Plan/Phase1/module_data.md
- Docs/Plan/Phase1/module_signals.md
- Docs/Plan/Phase1/logger.md

# 함수명 패턴 표준화 계획

## 1. 현재 패턴의 문제점
- 불일관성: calculate_*, *_indicator 등 혼재
- 중복성: indicators 모듈 내에서 _indicator 접미어 중복
- 모호성: _features 접미어의 불필요한 사용

## 2. 새로운 명명 규칙

### 2.1 기본 지표 함수 (단순 명사형)
```python
# 기존
calculate_rsi(data)
calculate_macd(data)

# 변경
rsi(data)
macd(data)
```

### 2.2 특징 생성 함수 (generate_ 접두어)
```python
# 기존
calculate_technical_features(data)
calculate_price_spread_features(data)

# 변경
generate_technical(data)
generate_price_spread(data)
```

### 2.3 복합 지표 함수 (단순 명사형)
```python
# 기존
zigzag_indicator(data)
triple_screen_indicator(data)

# 변경
zigzag(data)
triple_screen(data)
```

## 3. 변경 이점
1. **표준화**
   - TA-Lib 등 업계 표준 라이브러리와 동일한 스타일
   - 일관된 네이밍으로 코드 예측 가능성 향상

2. **가독성**
   - 간결하고 명확한 함수명
   - 불필요한 접두어/접미어 제거

3. **확장성**
   - ML/AI 파이프라인과의 자연스러운 통합
   - 함수형 프로그래밍 스타일 지원

4. **유지보수성**
   - 명확한 네이밍 규칙으로 새로운 함수 추가 용이
   - 코드 리뷰 및 디버깅 효율성 향상

## 4. 구현 계획
1. indicators/ 디렉토리의 모든 파일 수정
2. __init__.py 업데이트
3. 테스트 코드 수정
4. 문서 업데이트

## 5. 사용 예시
```python
# 데이터 파이프라인 예시
def process_market_data(data):
    return (data
        .pipe(rsi)                  # 기본 지표
        .pipe(triple_screen)        # 복합 지표
        .pipe(generate_technical)   # ML 특징 생성
        .pipe(model.predict)        # AI 예측
    )
```

## 6. 영향 범위
1. indicators/ 디렉토리의 모든 파일
2. 관련 문서
3. 테스트 코드
4. 의존성 있는 다른 모듈

## 7. 주의사항
- 하위 호환성 고려
- 단계적 변경 필요
- 충분한 테스트 커버리지 확보
